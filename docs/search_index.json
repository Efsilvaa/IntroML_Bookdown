[
["index.html", "EPSXXXX Introdução ao Aprendizado Máquina Prefácio Estrutura do livro", " EPSXXXX Introdução ao Aprendizado Máquina Eduardo F. Silva 2017-05-30 Prefácio Esse livro complementa a disciplina EPS:XXXX Introdução ao Aprendizado Máquina. As unidades apresentam os scripts em R dos exercícios apresentadados em sala. Esse é um material ainda em construção. Todas as sugestões e correções são bem vindas e podem enviadas para e{ponto}f{ponto}Silva{em}ufsc{ponto}br Estrutura do livro Os comandos em R serão apresentados blocos com o exemplo abaixo: devtools::install_github(&quot;rstudio/bookdown&quot;) "],
["sobre-o-autor.html", "Sobre o Autor", " Sobre o Autor bla bla bla …. "],
["ConceitosBasicos.html", "Unidade 1 R Project - Conceitos Básicos 1.1 Iniciando pelo básico 1.2 Iniciando uma variável do um valor 1.3 Inspecionando os valores das variáveis 1.4 Como nomear suas variáveis 1.5 Atalhos 1.6 Use a assistência da interface 1.7 Chamando funções 1.8 R Markdown", " Unidade 1 R Project - Conceitos Básicos Baseado nos livros de “R programming for Data Science” [Roger D. Peng] e “R for Data Science” [Garrett Grolemund e Hadley Wickham] 1.1 Iniciando pelo básico Vamos inicialmente usar R como uma calculadora! 1 / 40 * 1000 ## [1] 25 (50 + 31 + 7) / 3 ## [1] 29.33333 cos(pi / 2) ## [1] 6.123032e-17 Olhando R sob esse ponto de vista, é possível entender que a implementação da Linguagem R incorpora outros paradigmas de Linguagens de programação (Paradigma funcional), além daqueles que normalmente já estamos acostumados, como o Paradigma de orientação de objetos. Na verdade, na Linguagem R tudo é objeto! 1.2 Iniciando uma variável do um valor Quando atribuímos um valor a uma variável, estamos na verdade criando um objeto, onde um dos seus atributos é o valor daquela variável. No R novos objetos são criados com &lt;- (verifique qual atalho pode ser usado no seu Sistema operacional para gerar) &lt;-: x &lt;- 3 * 4 Todas os objetos criados em R são criados da mesma forma, usando um comando de atribuição: nome_do_objeto &lt;- valor Ao ler que o código, é como se fosse “o nome do objeto obtém valor”! Você fará muitas atribuições e digitar &lt;- pode se tornar cansativo. Tente não usar =: vai funcionar, mas vai causar confusão mais tarde. Em vez disso, use o atalho de teclado do RStudio: Alt + - (sinal de subtração). Observe que o RStudio automaticamente inclui espaços &lt;-, o que é uma boa prática de formatação de código. 1.3 Inspecionando os valores das variáveis x &lt;- 5 ## nada é impresso #`[1]` indica que o primeiro elemento contido em `x` é o valor `5`. x ## auto-printing ## [1] 5 print(x) ## o valor é impresso como resultado (nunca é usado!) ## [1] 5 ## já que a opção anterior é mais prática Obs: # é usado para inserir um comentário em R. Nada será executado. Outras atribuições: x &lt;- 1:20 x x &lt;- 1 # O valor anterior é sobrescrito x msg &lt;- &quot;hello&quot; #Para fazer a inicialização e ao mesmo tempo imprimir use (x &lt;- 1:10) # raramente usado Obs: O operador : é usado para criar sequência de inteiros. 1.4 Como nomear suas variáveis Nomes de objeto devem começar com uma letra, e conter apenas letras, números, _ e .. Se você quer que seus nomes sejam de fácil associação, então a recomendação é usar um padrão de codificação. Uma sugestão é o padrão snake case (meu_modelo) onde você separa palavras em letras minúsculas com _ Exemplos: eu_uso_snake_case otherPeopleUseCamelCase some.people.use.periods E_algumas.Pessoas_NAOusamPadrao 1.5 Atalhos esse_e_um_nome_longo &lt;- 2.5 Para inspecionar esse objeto, tente usar o funcionalidade auto completar do R Studio: Digete “esse”, pressione TAB, adicione caracteres até formar um prefixo único, então pressione ENTER. No caso de cometer um erro: esse_e_um_nome_longo deve ter valor 3.5 não 2,5. Use outro atalho de teclado para ajudá-lo a corrigi-lo. Digite esse, em seguida, pressione Ctrl/Cmd + seta para cima. Isso irá listar todos os comandos que você digitou que começam com aqueles caracteres. Use as setas para navegar e, em seguida, pressione ENTER para digitar novamente o comando. Mude de 2.5 a 3.5 e execute novamente. Outro detalhe: r_rocks &lt;- 2 ^ 3 Vamos tentar inspecionar esta variável: r_rock #&gt; Error: object &#39;r_rock&#39; not found R_rocks #&gt; Error: object &#39;R_rocks&#39; not found Há um contrato implícito entre você e o R: O R fará toda a computação tediosa para você, mas em troca, você deve ser completamente preciso em suas instruções. Ele é case sensitive 1.6 Use a assistência da interface Digite o código abaixo e note a assistência com as aspas emparelhadas: x &lt;- &quot;hello world&quot; Aspas e parênteses devem sempre vir em um par. RStudio faz o seu melhor para ajudá-lo, mas ainda é possível errar e acabar com uma incompatibilidade. Se isso acontecer, R irá mostrar-lhe o caractere de continuação de “+”: x &lt;- &quot;hello #+ O + diz-lhe que R está esperando por mais alguma entrada. Ele acha que você ainda não digitou tudo. Normalmente isso significa que você tenha esquecido ou um &quot; ou um ). Adicione o par ausente ou pressione ESC para abortar a expressão e tente novamente. Você também pode ver todas as variáveis/objetos criados no painel “Variáveis de Ambiente” no ‘R Studio’ Figure 1.1: Variáveis de ambiente visualizados no painel “Environment” no RStudio 1.7 Chamando funções R tem uma grande coleção de funções internas que são chamados assim: function_name(arg1 = val1, arg2 = val2, ...) Vamos tentar usar o seq(), que cria uma sequência de números. Digite ‘se’ e pressione TAB. Um popup mostra os possíveis comandos (funções). Digitando mais (um q), ou usando as setas cima/baixo, você pode selecionar a função ‘seq()’. Observe a dica flutuante que aparece, lembrando os argumentos da função e seu propósito. Se você quiser mais ajuda, pressione F1 para obter todos os detalhes no guia de ajuda no painel inferior direito. Pressione TAB uma vez mais, quando você selecionar a função que você quer. RStudio adicionará os parênteses correspondentes, abrindo ( e fechando ) parênteses para você. Digite os argumentos ‘1, 10’ e pressione ENTER. seq(1, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 Se você fizer uma atribuição, não verá o valor da atribuição. Mas como vimos antes, é fácil verificar o valor da variável logo em seguida: y &lt;- seq(1, 10, length.out = 5) y ## [1] 1.00 3.25 5.50 7.75 10.00 Um atalho pode ser inserir o commando entre parênteses (pouco usado): (y &lt;- seq(1, 10, length.out = 5)) ## [1] 1.00 3.25 5.50 7.75 10.00 1.8 R Markdown Esse arquivo foi preparado usando o RMarkdown dentro do RStudio. Os arquivos de tipo Rmarkdown podem der utilizados para estender os scriptos em R para a geração de conteúdo em vários formatos, como HTML e PDF. Os blocos de código são inseridos ao longo de texto, os quais podem ser executados como scrpts ou na geração dos documentos. Os blocos de código são chamados de chunk e podem ser executados clicando o botão de run ou posicionando o cursor dentro do chunck e pressionando Ctrl+Shift+Enter. Para adicionar um novo chunck use insert chunch na barra de ferramentas ou pressione Ctrl+Alt+I. Se o seu arquivo markdown for do tipo notebook, ao salvar o seu arquivo .Rmd no RStudio, um arquivo HTML também será salvo. (Para visualizar uma prévia do seu notebook em HTML, pressione preview na barra de ferramentas ou as teclas Ctrl+Shift+K. "],
["intro.html", "Unidade 2 Introduction", " Unidade 2 Introduction You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 2. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter 6. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 2.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 2.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 2.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 2.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package (Xie 2017) in this sample book, which was built on top of R Markdown and knitr (Xie 2015). References "],
["tipos-de-dados-classes-e-objetos.html", "Unidade 3 Tipos de Dados (Classes e Objetos) 3.1 Números", " Unidade 3 Tipos de Dados (Classes e Objetos) Tudo em R é objeto!! R tem cinco classes básicas ou atômicas de objetos: - caractere (string) - numérico (números reais) - inteiro - números complexos - Valores lógicos (TRUE/FALSE) #Caractere x &lt;- &quot;Bem vindo&quot; 3.1 Números Números em R são geralmente tratados como objetos (ex. double precision real numbers) Se você precisa especificamente de um inteiro (raramente), é necessário especificar o sufuxo L O valor NaN representa um valor não identificado (“not a number”); e.g. 0 / 0; NaN pode também representar valores ausentes (não se preocupe agora com isso, mas mostra que a linguagem foi concebida para identificar essa situação ) #Numérico x &lt;- 5 x ## [1] 5 is.numeric(x) ## [1] TRUE is.integer(x) ## [1] FALSE #Inteiro (###Numérico x &lt;- 5 x ## [1] 5 is.numeric(x) ## [1] TRUE is.integer(x) ## [1] FALSE 3.1.1 Inteiro (raramente usado) x &lt;- 5L x ## [1] 5 is.numeric(x) ## [1] TRUE is.integer(x) ## [1] TRUE 3.1.2 Números Complexos (Uso não muito comum) x &lt;- 1 + 4i x ## [1] 1+4i is.numeric(x) ## [1] FALSE is.integer(x) ## [1] FALSE is.complex(x) ## [1] TRUE 3.1.3 Lógico x &lt;- TRUE x ## [1] TRUE x &lt;- TRUE x &lt;- (3 &lt; 4) x ## [1] TRUE "],
["estruturas-de-dados.html", "Unidade 4 Estruturas de dados 4.1 Vetores 4.2 Criando Vetores 4.3 Attributes 4.4 Misturando Objetos 4.5 Coerção explícita 4.6 Matrizes 4.7 cbind-ing and rbind-ing 4.8 Listas (list) 4.9 Fator (factor) 4.10 Valores ausentes (Missing Values) 4.11 Data Frames (Finalmente a cereja do bolo :)) 4.12 Nomes 4.13 Sumário", " Unidade 4 Estruturas de dados 4.1 Vetores A estrutura mais básica do R é um vetor - Um vetor pode conter apenas objetos da mesma classe básica - Existe um outro objeto chamado lista, que é representado como um vetor, mas pode conter objetos de classes diferentes - Vetores vazios podem ser criados com a função vector(). - O operador : é usado para gerar/representar uma sequência de números. x &lt;- 1:20 x ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 4.2 Criando Vetores A função c() concatena os seus argumentos em um vetor. x &lt;- c(0.5, 0.6) ## numeric x &lt;- c(TRUE, FALSE) ## logical x &lt;- c(T, F) ## logical x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ## character x &lt;- 9:29 ## integer x &lt;- c(1+0i, 2+4i) ## complex Para a criação de um vetor vazio podemos usar a função vector() x &lt;- vector(&quot;numeric&quot;, length = 10) x ## [1] 0 0 0 0 0 0 0 0 0 0 4.3 Attributes Os objetos em possuem vários atributos: - nomes, dimnames - dimensão (e.g. matrizes, arrays) - classe - comprimento - outras atributos definidos pelo usuário/metadata O nome dos atributos de um objeto pode ser acessado usando a função attributes(). attributes(x) 4.4 Misturando Objetos Quando objetos diferente são misturados em um vetor, a coerção ajusta os tipos de modo que todos elementos mantenham sejam da mesma classe. y &lt;- c(1.7, &quot;a&quot;) ## character y &lt;- c(TRUE, 2) ## numeric y &lt;- c(&quot;a&quot;, TRUE) ## character 4.5 Coerção explícita Objetos de uma classe podem ser sua classe alterada usando as funções as.*() x &lt;- 0:6 class(x) # &quot;integer&quot; ## [1] &quot;integer&quot; as.numeric(x) ## [1] 0 1 2 3 4 5 6 as.logical(x) # FALSE .... ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE as.character(x) # &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; Coerções não permitidas geram NA (Não avaliado). x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) as.numeric(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA as.logical(x) ## [1] NA NA NA as.complex(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA 4.6 Matrizes Matrizes são vetores com duas ou mais dimensões. A dimensão é na verdade um vetor com dois valores inteiros (número de linhas, número d colunas). Uma característica importante é que todos os elementos de uma matriz são do mesmo tipo. Use attributes para explorar a estrutura de um tipo de dados. m &lt;- matrix(nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA dim(m) ## [1] 2 3 attributes(m) ## $dim ## [1] 2 3 Matrizes normalmente são construídas por colunas, de modo que uma sequência de dados é lido como se estivesse se iniciando na posição superior esquerda, elemento na [linha,coluna] = [1,1], continuando até o último elemento da coluna, e assim por diante. m &lt;- matrix(1:6, nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Contudo, as matrizes podem também ser criadas a partir de vetores, basta definir seus atributos d dimensão, como no exemplo abaixo: m &lt;- 1:10 m ## [1] 1 2 3 4 5 6 7 8 9 10 dim(m) &lt;- c(2, 5) m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 4.7 cbind-ing and rbind-ing Existem várias situações onde mais prático criar matrizes adicionando colunas as já existentes (column-binding) ou adicionando linhas (row-binding_) com cbind() and rbind(). x &lt;- 1:3 y &lt;- 10:12 cbind(x, y) ## x y ## [1,] 1 10 ## [2,] 2 11 ## [3,] 3 12 rbind(x, y) ## [,1] [,2] [,3] ## x 1 2 3 ## y 10 11 12 4.8 Listas (list) Listas é uma poderosa estrutura de dados. É utilizada de várias formas no contexto de R, muitas vezes passando desapercebida. Uma lista nada mais é que um vetor que pode conter elementos de diferentes classes. x &lt;- list(1,&#39;a&#39;,TRUE, 1 + 4i ) x ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] 1+4i x[1] # Primeiro classe da lista ## [[1]] ## [1] 1 x[[1]] # Primeiro elemento da primeira classe da lista ## [1] 1 4.9 Fator (factor) Fatores são usados para representar valores de variáveis categóricas. Esses fatores podem ser ordenados ou não-ordenados. Pode-se pensar nos fatores como sendo números inteiros, cada um representando uma categoria representado por um nome padrão (label). Fatores são tratados de maneira distinta em algums modelos, como por exemplo regressão linear lm() e regressão linear generalizada glm() Usar fatores com nomes é melhor do que usar números devido a legibilidade e transparências. Por exemplo, usar “Masculino” e “Feminino” descreve melhor os possiveis valores da variável categoria “Sexo” do que os valores 1 e 2. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: no yes table(x) ## x ## no yes ## 2 3 unclass(x) # retorna x sem os atributos da classe factor, ou seja, os níveis(levels) ## [1] 2 2 1 2 1 ## attr(,&quot;levels&quot;) ## [1] &quot;no&quot; &quot;yes&quot; A ordem dos níveis levels pode ser definida usando o argumento levels nafunção factor(). Isso pode ser importante em modelos lineares como a regressão linear já que o primeiro nível é usado como base. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: yes no 4.10 Valores ausentes (Missing Values) “Missing values” são definidos por NA (non-available) or NaN (not a number) e não são permitidos em algumas operações matemática. Muito usado!!!! Não substimen sua utilidade quando estivermos limpando e ajustando os dados. is.na() é usado para testar objetos se eles são NA is.nan() é usado para testar elementos se eles são NaN NA possuem classe. Ou seja, existem inteiros NA, caracteres (character) NA e etc. O NaN é também NA mas o inverso não é verdadeiro x &lt;- c(1, 2, NA, 10, 3) is.na(x) ## [1] FALSE FALSE TRUE FALSE FALSE is.nan(x) ## [1] FALSE FALSE FALSE FALSE FALSE x &lt;- c(1, 2, NaN, NA, 4) is.na(x) ## [1] FALSE FALSE TRUE TRUE FALSE is.nan(x) ## [1] FALSE FALSE TRUE FALSE FALSE 4.11 Data Frames (Finalmente a cereja do bolo :)) Data frames é uma estrutura de dados usada para armazenar dados em tabela. A diferença para matriz é que em data frames cada coluna pode conter um tipo de vaiável. Ou seja, é simplesmente uma tabela Pode ser visto como um caso especial de lista onde todos os elementos da lista possuem o mesmo comprimento. Cada elemento da lista é na verdade uma coluna de uma tabela, e o comprimento decada elemnto da lista o número de linhas da tabela. Diferente das matrizes, data frames podem armazenar diferentes classes de objetos, uma em cada coluna (como uma lista); Todos os elementos das matrizes são da mesma classe Data frames possuem um atributo especial chamado row.names Data frames é o formato normalmente utilizado na importação de dados, resultado das funções read.table() ou read.csv() Pode ser convertido para matriz por meio da função data.matrix() x &lt;- data.frame(foo = 1:4, bar = c(T, T, F, F)) x ## foo bar ## 1 1 TRUE ## 2 2 TRUE ## 3 3 FALSE ## 4 4 FALSE nrow(x) ## [1] 4 ncol(x) ## [1] 2 4.12 Nomes Objetos em R podem ter nomes associados, o que torna os códigos mais fácil de serem lidos e compreendidos. x &lt;- 1:3 names(x) ## NULL names(x) &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;norf&quot;) x ## foo bar norf ## 1 2 3 names(x) ## [1] &quot;foo&quot; &quot;bar&quot; &quot;norf&quot; Listas também podem ter nomes associados x &lt;- list(a = 1, b = 2, c = 3) x ## $a ## [1] 1 ## ## $b ## [1] 2 ## ## $c ## [1] 3 E matrizes. m &lt;- matrix(1:4, nrow = 2, ncol = 2) dimnames(m) &lt;- list(c(&#39;a&#39;, &#39;b&#39;), c(&#39;c&#39;, &#39;d&#39;)) m ## c d ## a 1 3 ## b 2 4 4.13 Sumário Estruturas de Dados em R classes básicas: numérica, lógica, caracter, inteiro, número complexo vetores, listas fatores missing values data frames nomes "],
["literature.html", "Unidade 5 Literature", " Unidade 5 Literature Here is a review of existing methods. "],
["methods.html", "Unidade 6 Methods", " Unidade 6 Methods We describe our methods in this chapter. "],
["applications.html", "Unidade 7 Applications 7.1 Example one 7.2 Example two", " Unidade 7 Applications Some significant applications are demonstrated in this chapter. 7.1 Example one 7.2 Example two "],
["final-words.html", "Unidade 8 Final Words", " Unidade 8 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
