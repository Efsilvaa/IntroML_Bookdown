[
["prefacio.html", "EPSXXXX Introdução ao Aprendizado Máquina Prefácio Estrutura do livro", " EPSXXXX Introdução ao Aprendizado Máquina Eduardo F. Silva 2017-06-14 Prefácio Esse site complementa a disciplina EPS:XXXX Introdução ao Aprendizado Máquina. As unidades apresentam os scripts em R dos exercícios apresentadados em sala. Esse é um material ainda em construção. Todas as sugestões e correções são bem vindas e podem enviadas para e{.}f{.}Silva{em}ufsc{.}br Estrutura do livro Os comandos em R serão apresentados blocos com o exemplo abaixo: x &lt;- 1:10 x "],
["sobre-o-autor.html", "Sobre o Autor", " Sobre o Autor Eduardo F. Silva Professor Departamento de Engenharia de Produção e Sistemas Universidade Federal de Santa Catarina e{.}f{.}Silva{em}ufsc{.}br "],
["ConceitosBasicos.html", "Unidade 1 R Project - Conceitos Básicos 1.1 Iniciando pelo básico 1.2 Iniciando uma variável do um valor 1.3 Inspecionando os valores das variáveis 1.4 Como nomear suas variáveis 1.5 Atalhos 1.6 Use a assistência da interface 1.7 Chamando funções 1.8 R Markdown", " Unidade 1 R Project - Conceitos Básicos Referências utilizadas para esse capítulo: R for Data Science. Garrett Grolemund e Hadley Wickham (Grolemund and Wickham 2016) R programming for Data Science. Roger D. Peng (Peng 2015) E recentemente encontrei um ótimo livro em português, criado pelo Prof. Marcelo Perlin da UFRGS, cuja parte de introdução ao R é bem completa e se encaixa perfeitamente ao nosso curso. Processamento e Modelagem de Dados Financeiros com o R. Marcelo Perlin (Perlin 2017) 1.1 Iniciando pelo básico Vamos inicialmente usar R como uma calculadora! 1 / 40 * 1000 ## [1] 25 (50 + 31 + 7) / 3 ## [1] 29.33333 cos(pi / 2) ## [1] 6.123032e-17 Olhando R sob esse ponto de vista, é possível entender que a implementação da Linguagem R incorpora outros paradigmas de Linguagens de programação (Paradigma funcional), além daqueles que normalmente já estamos acostumados, como o Paradigma de orientação de objetos. Na verdade, na Linguagem R tudo é objeto! 1.2 Iniciando uma variável do um valor Quando atribuímos um valor a uma variável, estamos na verdade criando um objeto, onde um dos seus atributos é o valor daquela variável. No R novos objetos são criados com &lt;- (verifique qual atalho pode ser usado no seu Sistema operacional para gerar) &lt;-: x &lt;- 3 * 4 Todas os objetos criados em R são criados da mesma forma, usando um comando de atribuição: nome_do_objeto &lt;- valor Ao ler que o código, é como se fosse “o nome do objeto obtém valor”! Você fará muitas atribuições e digitar &lt;- pode se tornar cansativo. Tente não usar =: vai funcionar, mas vai causar confusão mais tarde. Em vez disso, use o atalho de teclado do RStudio: Alt + - (sinal de subtração). Observe que o RStudio automaticamente inclui espaços &lt;-, o que é uma boa prática de formatação de código. 1.3 Inspecionando os valores das variáveis x &lt;- 5 ## nada é impresso #`[1]` indica que o primeiro elemento contido em `x` é o valor `5`. x ## auto-printing ## [1] 5 print(x) ## o valor é impresso como resultado (nunca é usado!) ## [1] 5 ## já que a opção anterior é mais prática Obs: # é usado para inserir um comentário em R. Nada será executado. Outras atribuições: x &lt;- 1:20 x x &lt;- 1 # O valor anterior é sobrescrito x msg &lt;- &quot;hello&quot; #Para fazer a inicialização e ao mesmo tempo imprimir use (x &lt;- 1:10) # raramente usado Obs: O operador : é usado para criar sequência de inteiros. 1.4 Como nomear suas variáveis Nomes de objeto devem começar com uma letra, e conter apenas letras, números, _ e .. Se você quer que seus nomes sejam de fácil associação, então a recomendação é usar um padrão de codificação. Uma sugestão é o padrão snake case (meu_modelo) onde você separa palavras em letras minúsculas com _ Exemplos: eu_uso_snake_case otherPeopleUseCamelCase some.people.use.periods E_algumas.Pessoas_NAOusamPadrao 1.5 Atalhos esse_e_um_nome_longo &lt;- 2.5 Para inspecionar esse objeto, tente usar o funcionalidade auto completar do R Studio: Digete “esse”, pressione TAB, adicione caracteres até formar um prefixo único, então pressione ENTER. No caso de cometer um erro: esse_e_um_nome_longo deve ter valor 3.5 não 2,5. Use outro atalho de teclado para ajudá-lo a corrigi-lo. Digite esse, em seguida, pressione Ctrl/Cmd + seta para cima. Isso irá listar todos os comandos que você digitou que começam com aqueles caracteres. Use as setas para navegar e, em seguida, pressione ENTER para digitar novamente o comando. Mude de 2.5 a 3.5 e execute novamente. Outro detalhe: r_rocks &lt;- 2 ^ 3 Vamos tentar inspecionar esta variável: r_rock #&gt; Error: object &#39;r_rock&#39; not found R_rocks #&gt; Error: object &#39;R_rocks&#39; not found Há um contrato implícito entre você e o R: O R fará toda a computação tediosa para você, mas em troca, você deve ser completamente preciso em suas instruções. Ele é case sensitive 1.6 Use a assistência da interface Digite o código abaixo e note a assistência com as aspas emparelhadas: x &lt;- &quot;hello world&quot; Aspas e parênteses devem sempre vir em um par. RStudio faz o seu melhor para ajudá-lo, mas ainda é possível errar e acabar com uma incompatibilidade. Se isso acontecer, R irá mostrar-lhe o caractere de continuação de “+”: x &lt;- &quot;hello #+ O + diz-lhe que R está esperando por mais alguma entrada. Ele acha que você ainda não digitou tudo. Normalmente isso significa que você tenha esquecido ou um &quot; ou um ). Adicione o par ausente ou pressione ESC para abortar a expressão e tente novamente. Você também pode ver todas as variáveis/objetos criados no painel “Variáveis de Ambiente” no ‘R Studio’ Figura 1.1: Variáveis de ambiente visualizados no painel “Environment” no RStudio 1.7 Chamando funções R tem uma grande coleção de funções internas que são chamados assim: function_name(arg1 = val1, arg2 = val2, ...) Vamos tentar usar o seq(), que cria uma sequência de números. Digite ‘se’ e pressione TAB. Um popup mostra os possíveis comandos (funções). Digitando mais (um q), ou usando as setas cima/baixo, você pode selecionar a função ‘seq()’. Observe a dica flutuante que aparece, lembrando os argumentos da função e seu propósito. Se você quiser mais ajuda, pressione F1 para obter todos os detalhes no guia de ajuda no painel inferior direito. Pressione TAB uma vez mais, quando você selecionar a função que você quer. RStudio adicionará os parênteses correspondentes, abrindo ( e fechando ) parênteses para você. Digite os argumentos ‘1, 10’ e pressione ENTER. seq(1, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 Se você fizer uma atribuição, não verá o valor da atribuição. Mas como vimos antes, é fácil verificar o valor da variável logo em seguida: y &lt;- seq(1, 10, length.out = 5) y ## [1] 1.00 3.25 5.50 7.75 10.00 Um atalho pode ser inserir o commando entre parênteses (pouco usado): (y &lt;- seq(1, 10, length.out = 5)) ## [1] 1.00 3.25 5.50 7.75 10.00 1.8 R Markdown Esse arquivo foi preparado usando o RMarkdown dentro do RStudio. Os arquivos de tipo Rmarkdown podem der utilizados para estender os scriptos em R para a geração de conteúdo em vários formatos, como HTML e PDF. Os blocos de código são inseridos ao longo de texto, os quais podem ser executados como scrpts ou na geração dos documentos. Os blocos de código são chamados de chunk e podem ser executados clicando o botão de run ou posicionando o cursor dentro do chunck e pressionando Ctrl+Shift+Enter. Para adicionar um novo chunck use insert chunch na barra de ferramentas ou pressione Ctrl+Alt+I. Se o seu arquivo markdown for do tipo notebook, ao salvar o seu arquivo .Rmd no RStudio, um arquivo HTML também será salvo. (Para visualizar uma prévia do seu notebook em HTML, pressione preview na barra de ferramentas ou as teclas Ctrl+Shift+K. References "],
["tipos-basicos-de-dados.html", "Unidade 2 Tipos Básicos de Dados 2.1 Números 2.2 Lógico 2.3 Sequência de Caracteres", " Unidade 2 Tipos Básicos de Dados Tudo em R é objeto!! R tem cinco classes básicas ou atômicas de objetos: numéro em geral (números reais) inteiro números complexos Valores lógicos (TRUE/FALSE) caractere (string) #Caractere x &lt;- &quot;Bem vindo&quot; 2.1 Números Números em R são geralmente tratados como objetos (ex. Números reais) Se você precisa especificamente de um inteiro (raramente), é necessário especificar o sufuxo L O valor NaN representa um valor não identificado (“not a number”); e.g. 0 / 0; NaN pode também representar valores ausentes (não se preocupe agora com isso, mas mostra que a linguagem foi concebida para identificar essa situação ) 2.1.1 Numérico x &lt;- 5 x ## [1] 5 is.numeric(x) ## [1] TRUE is.integer(x) ## [1] FALSE 2.1.2 Inteiro (raramente usado) x &lt;- 5L x ## [1] 5 is.numeric(x) ## [1] TRUE is.integer(x) ## [1] TRUE 2.1.3 Números Complexos (Uso não muito comum) x &lt;- 1 + 4i x ## [1] 1+4i is.numeric(x) ## [1] FALSE is.integer(x) ## [1] FALSE is.complex(x) ## [1] TRUE 2.2 Lógico x &lt;- TRUE x ## [1] TRUE x &lt;- TRUE x &lt;- (3 &lt; 4) x ## [1] TRUE 2.3 Sequência de Caracteres x &lt;- &quot;Bem Vindo ao R e ao RStudio&quot; x ## [1] &quot;Bem Vindo ao R e ao RStudio&quot; "],
["estruturas-de-dados.html", "Unidade 3 Estruturas de dados 3.1 Vetores 3.2 Criando Vetores 3.3 Atributos (Attributes) 3.4 Misturando Objetos 3.5 Coerção explícita 3.6 Matrizes 3.7 cbind-ing and rbind-ing 3.8 Listas (list) 3.9 Fator (factor) 3.10 Valores ausentes (Missing Values) 3.11 Data Frames (Finalmente a cereja do bolo :)) 3.12 Nomes 3.13 Sumário", " Unidade 3 Estruturas de dados 3.1 Vetores A estrutura mais básica do R é um vetor - Um vetor pode conter apenas objetos da mesma classe básica - Existe um outro objeto chamado lista, que é representado como um vetor, mas pode conter objetos de classes diferentes - Vetores vazios podem ser criados com a função vector(). - O operador : é usado para gerar/representar uma sequência de números. x &lt;- 1:20 x ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 3.2 Criando Vetores A função c() concatena os seus argumentos em um vetor. x &lt;- c(0.5, 0.6) ## numeric x &lt;- c(TRUE, FALSE) ## logical x &lt;- c(T, F) ## logical x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ## character x &lt;- 9:29 ## integer x &lt;- c(1+0i, 2+4i) ## complex Para a criação de um vetor vazio podemos usar a função vector() x &lt;- vector(&quot;numeric&quot;, length = 10) x ## [1] 0 0 0 0 0 0 0 0 0 0 3.3 Atributos (Attributes) Os objetos em possuem vários atributos: - nomes, dimnames - dimensão (e.g. matrizes, arrays) - classe - comprimento - outras atributos definidos pelo usuário/metadata O nome dos atributos de um objeto pode ser acessado usando a função attributes(). attributes(x) ## NULL 3.4 Misturando Objetos Quando objetos diferente são misturados em um vetor, a coerção ajusta os tipos de modo que todos elementos mantenham sejam da mesma classe. y &lt;- c(1.7, &quot;a&quot;) ## character y &lt;- c(TRUE, 2) ## numeric y &lt;- c(&quot;a&quot;, TRUE) ## character 3.5 Coerção explícita Objetos de uma classe podem ser sua classe alterada usando as funções as.*() x &lt;- 0:6 class(x) # &quot;integer&quot; ## [1] &quot;integer&quot; as.numeric(x) ## [1] 0 1 2 3 4 5 6 as.logical(x) # FALSE .... ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE as.character(x) # &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; Coerções não permitidas geram NA (Não avaliado). x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) as.numeric(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA as.logical(x) ## [1] NA NA NA as.complex(x) ## Warning: NAs introduced by coercion ## [1] NA NA NA 3.6 Matrizes Matrizes são vetores com duas ou mais dimensões. A dimensão é na verdade um vetor com dois valores inteiros (número de linhas, número d colunas). Uma característica importante é que todos os elementos de uma matriz são do mesmo tipo. Use attributes para explorar a estrutura de um tipo de dados. m &lt;- matrix(nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA dim(m) ## [1] 2 3 attributes(m) ## $dim ## [1] 2 3 Matrizes normalmente são construídas por colunas, de modo que uma sequência de dados é lido como se estivesse se iniciando na posição superior esquerda, elemento na [linha,coluna] = [1,1], continuando até o último elemento da coluna, e assim por diante. m &lt;- matrix(1:6, nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Contudo, as matrizes podem também ser criadas a partir de vetores, basta definir seus atributos d dimensão, como no exemplo abaixo: m &lt;- 1:10 m ## [1] 1 2 3 4 5 6 7 8 9 10 dim(m) &lt;- c(2, 5) m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 3.7 cbind-ing and rbind-ing Existem várias situações onde mais prático criar matrizes adicionando colunas as já existentes (column-binding) ou adicionando linhas (row-binding_) com cbind() and rbind(). x &lt;- 1:3 y &lt;- 10:12 cbind(x, y) ## x y ## [1,] 1 10 ## [2,] 2 11 ## [3,] 3 12 rbind(x, y) ## [,1] [,2] [,3] ## x 1 2 3 ## y 10 11 12 3.8 Listas (list) Listas é uma poderosa estrutura de dados. É utilizada de várias formas no contexto de R, muitas vezes passando desapercebida. Uma lista nada mais é que um vetor que pode conter elementos de diferentes classes. x &lt;- list(1,&quot;a&quot;,TRUE, 1 + 4i ) x ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] 1+4i x[1] # Primeiro classe da lista ## [[1]] ## [1] 1 x[[1]] # Primeiro elemento da primeira classe da lista ## [1] 1 3.9 Fator (factor) Fatores são usados para representar valores de variáveis categóricas. Esses fatores podem ser ordenados ou não-ordenados. Pode-se pensar nos fatores como sendo números inteiros, cada um representando uma categoria representado por um nome padrão (label). Fatores são tratados de maneira distinta em algums modelos, como por exemplo regressão linear lm() e regressão linear generalizada glm() Usar fatores com nomes é melhor do que usar números devido a legibilidade e transparências. Por exemplo, usar “Masculino” e “Feminino” descreve melhor os possiveis valores da variável categoria “Sexo” do que os valores 1 e 2. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: no yes table(x) ## x ## no yes ## 2 3 unclass(x) # retorna x sem os atributos da classe factor, ou seja, os níveis(levels) ## [1] 2 2 1 2 1 ## attr(,&quot;levels&quot;) ## [1] &quot;no&quot; &quot;yes&quot; A ordem dos níveis levels pode ser definida usando o argumento levels na função factor(). Isso pode ser importante em modelos lineares como a regressão linear já que o primeiro nível é usado como base. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: yes no Usando a função attributes attributes(x) #Aqui eu encontro o método &quot;levels&quot; ## $levels ## [1] &quot;yes&quot; &quot;no&quot; ## ## $class ## [1] &quot;factor&quot; levels(x) ## [1] &quot;yes&quot; &quot;no&quot; 3.10 Valores ausentes (Missing Values) “Missing values” são definidos por NA (non-available) or NaN (not a number) e não são permitidos em algumas operações matemática. Muito usado!!!! Não substimen sua utilidade quando estivermos limpando e ajustando os dados. is.na() é usado para testar objetos se eles são NA is.nan() é usado para testar elementos se eles são NaN NA possuem classe. Ou seja, existem inteiros NA, caracteres (character) NA e etc. O NaN é também NA mas o inverso não é verdadeiro x &lt;- c(1, 2, NA, 10, 3) is.na(x) ## [1] FALSE FALSE TRUE FALSE FALSE is.nan(x) ## [1] FALSE FALSE FALSE FALSE FALSE x &lt;- c(1, 2, NaN, NA, 4) is.na(x) ## [1] FALSE FALSE TRUE TRUE FALSE is.nan(x) ## [1] FALSE FALSE TRUE FALSE FALSE 3.11 Data Frames (Finalmente a cereja do bolo :)) Data frames é uma estrutura de dados usada para armazenar dados em tabela. A diferença para matriz é que em data frames cada coluna pode conter um tipo de vaiável. Ou seja, é simplesmente uma tabela Pode ser visto como um caso especial de lista onde todos os elementos da lista possuem o mesmo comprimento. Cada elemento da lista é na verdade uma coluna de uma tabela, e o comprimento decada elemnto da lista o número de linhas da tabela. Diferente das matrizes, data frames podem armazenar diferentes classes de objetos, uma em cada coluna (como uma lista); Todos os elementos das matrizes são da mesma classe Data frames possuem um atributo especial chamado row.names Data frames é o formato normalmente utilizado na importação de dados, resultado das funções read.table() ou read.csv() Pode ser convertido para matriz por meio da função data.matrix() x &lt;- data.frame(foo = 1:4, bar = c(T, T, F, F)) x ## foo bar ## 1 1 TRUE ## 2 2 TRUE ## 3 3 FALSE ## 4 4 FALSE nrow(x) ## [1] 4 ncol(x) ## [1] 2 3.12 Nomes Objetos em R podem ter nomes associados, o que torna os códigos mais fácil de serem lidos e compreendidos. x &lt;- 1:3 names(x) ## NULL names(x) &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;norf&quot;) x ## foo bar norf ## 1 2 3 names(x) ## [1] &quot;foo&quot; &quot;bar&quot; &quot;norf&quot; Listas também podem ter nomes associados x &lt;- list(a = 1, b = 2, c = 3) x ## $a ## [1] 1 ## ## $b ## [1] 2 ## ## $c ## [1] 3 E matrizes. m &lt;- matrix(1:4, nrow = 2, ncol = 2) dimnames(m) &lt;- list(c(&#39;a&#39;, &#39;b&#39;), c(&#39;c&#39;, &#39;d&#39;)) m ## c d ## a 1 3 ## b 2 4 3.13 Sumário Estruturas de Dados em R classes básicas: numérica, lógica, caracter, inteiro, número complexo vetores, listas fatores missing values data frames nomes "],
["mais-operacoes-basicas-em-r.html", "Unidade 4 Mais operações básicas em R 4.1 Função sessionInfo()", " Unidade 4 Mais operações básicas em R Para esse tópico vamos seguir como referência o https://msperlin.github.io/pmdfR-Online/operacoes-basicas-no-r.html. Finalmente, é importante ainda enfatizar os seguinte tópicos: 4.1 Função sessionInfo() Quando começamos a trabalhar com R, precisamos entender que estamos dentro de uma sessão, a qual contém nossas variáveis de ambiente, nossos dados, os pacotes carregados. Quando iniciamos uma nova sessão em R (ou um novo projeto), um conjunto totalmente novo e vazio é criado, assim teremos novamente que carregar nossos dados,variáveis de ambiente, pacotes e etc. Claro que todo esse comportamento pode ser configurado, mas vamos comecar com o básico :-) Muitas vezes precisamos tirar uma foto da sessão para saber o que está carregado, para que outro analista possa replicar o mesmo ambiente e enventualmente confirmar as análises realizadas. Para isso existe a função sessionInfo() que tem exatamente esta tarefa, mostrando quais pacotes estão carregados, inclusive anontando a versão do pacote utilizado. Teste a função sessionInfo() e verifique o que está carregado na sua sessão! sessionInfo() "],
["bancos-de-dados.html", "Unidade 5 Bancos de Dados", " Unidade 5 Bancos de Dados O Ambiente R já traz na sua biblioteca base vários conjuntos de dados que podem ser utilizados para testes. Para explorar esses dados use a função data(). data() # Apresenta os vários conjuntos de dados disponíveis na sua sessão no R. help(&quot;USArrests&quot;) # Abre na janela help informações sobre esses dados data(&quot;iris&quot;) # Carrega os dados na sua sessão É comum os pacotes incorporarem outros dados que são utilizados no manual do pacote para explorar a funcionalidade do mesmo. library(ggplot2) # Carrege o pacote ggplot2 data() # Verifique os dados adicionais disponibilizados por esse pacote "],
["criacao-de-projetos-em-r.html", "Unidade 6 Criação de Projetos em R 6.1 Criando Projetos no RStudio", " Unidade 6 Criação de Projetos em R 6.1 Criando Projetos no RStudio Um projeto em R é um container da sua sessão. Todo o seu ambiente, variáveis e pacotes carregados, ficam confinados no projeto. Fisicamente, o seu projeto é um diretório contendo um arquivo “nome_do_projeto.Rproj”. A forma como seu projeto é organizado pode contribuir significativamente no resultado do seu trabalho. Cada pesquisador possui seu estilo próprio de organizar seu projeto. Enquanto você ainda não desenvolveu o seu, vou sugerir uma organização simples e bem básica que incorpora algumas das boas práticas a serem observadas quando trabalhando em projetos R dentro do RStudio. A base para este esquema foi criada a partir das recomendações da pesquisadora Page Piccinini, e inicialmente se resumirá a criar diretórios para organizar suas análises. 6.1.1 Criando diretórios no seu projeto Inicialmente crie seu projeto “ML_Aula_1” no diretório “ML_Aula_1” . Você pode criar o diretório quando criar o projeto no RStudio ou simplesmente criá-lo antes criar um novo projeto no RStudio. Dentro do diretório do seu projeto, crie os seguintes subdiretórios: dados: Esses diretório conterá os dados usados na sua análise. Normalmente em uma versão ainda bruta, mas ainda não subetida ao préprocessamento. Dessa forma será mais simples escrever seus sripts importando os dados desta fonte, já convertidos para o formato Rdata, ao invés de importar os dados da fonte original (excel, csv, url e etc.) figuras: Como várias figuras vão sendo geradas ao longo da análise, é interessante salvar neste diretório algumas cópias para relatórios preliminares. scritps: Esse é um dos diretórios mais importantes do seu projeto. Nele estarão todos os seus scrits (arquivos de análise), os quais serão aos poucos refinados durante o processo de análise. reports: Aqui serão criados os arquivos geradores do seus relatórios de análise, que podem ser arquivos markdown criados no próprio ambiente do RStudio, arquivos em Latex, MS Word e etc. 6.1.2 Scripts de análise No diretório scripts uma boa dica dica a ser seguida é a indicada por Marcelo Perlin no capítulo 9 do seu livro, onde ele recomenda organizar os scrips de pesquisa em quatro etapas: Importação dos dados Limpeza e estruturação dos dados Modelagem e teste de hipóteses Reportando os resultados Mas o interessante é a sugestão é criar uma nomenclatura para a nomeação dos scripts, relacionadas sequenciamente com as etapas da pesquisa. “Um exemplo seria nomear o código de importação de dados como 1-Import-and-clean-data.R, o código de modelagem como 2-build-report-models.R e assim sucessivamente. O efeito prático é que o uso de um contador na primeira letra do nome do arquivo faz com que a ordem de execução do programa fique bastante clara.” — Marcelo Perlin Mais adiante veremos como estruturar os scripts internamente. "],
["criacao-de-graficos-basicos.html", "Unidade 7 Criação de Gráficos Básicos 7.1 Sumário dos 5 números 7.2 Importância da visualização dos dados 7.3 Tipos básicos de gráficos1 7.4 Uma variávél contínua 7.5 Variável categórica (ou discreta) 7.6 Duas Variáveis contínuas 7.7 Duas Variáves categóricas 7.8 Duas variáveis: Uma categórica e outra numérica 7.9 Três variáveis discretas (categorias ou fatores em R) 7.10 Três Variáveis: Uma númérica e duas categóricas 7.11 Três variáveis: Duas numéricas e uma variável categórica 7.12 Três variáveis numéricas", " Unidade 7 Criação de Gráficos Básicos O objetivo dessa sessão é a familiarização com os tipos básicos de gráfico que podem ser usados para descrever o comportamento e o relacionamento entre os dados de um estudo estatístico. 7.1 Sumário dos 5 números O sumário dos 5 números é conhecido como um conjunto de estatísticas descritivas que revelam os percintis gerais mais significativos em uma amostra de dados. Estes são: 1. Mínimo 2. Primeiro quartil 3. Mediana 4. Terceiro quartil 5. Máximo Por exemplo, em R podemos obter esse sumário por meio do comando summary. Vamos carregar os dados “cars” que apresenta a velocidade e a distância de parada de alguns carros (gravado em 1920!). help(&quot;cars&quot;) data(&quot;cars&quot;) summary(cars) 7.2 Importância da visualização dos dados Apesar das várias medidas estatísticas descritivas disponível, a Figura 7.1 mostra porque a visualização dos dados é muito importante. Figura 7.1: Artigo Same Stats, Diferent Graphs (Matejka and Fitzmaurice 2017) 7.3 Tipos básicos de gráficos1 Inicialmente, será necessário simular alguns dados para serem usados como fonte na geração de gráficos. Os dados serão armazenados em um data frame contendo 3 variáveis categóricas (fatores em R) e 4 variáveis contínuas. ## Simulando os dados ## 3 variáveis categóricas FacVar1 = as.factor(rep(c(&quot;level1&quot;, &quot;level2&quot;), 25)) FacVar2 = as.factor(rep(c(&quot;levelA&quot;, &quot;levelB&quot;, &quot;levelC&quot;), 17)[-51]) FacVar3 = as.factor(rep(c(&quot;levelI&quot;, &quot;levelII&quot;, &quot;levelIII&quot;, &quot;levelIV&quot;), 13)[-c(51:52)]) ## 4 variáveis númericas set.seed(123) # referência para uniformizar as variáveis geradas NumVar1 = round(rnorm(n = 50, mean = 1000, sd = 50), digits = 2) ## Distribuição Normal NumVar2 = round(runif(n = 50, min = 500, max = 1500), digits = 2) ## Distribuição Uniforme NumVar3 = round(rexp(n = 50, rate = 0.001)) ## Distribuição exponencial NumVar4 = 2001:2050 simData = data.frame(FacVar1, FacVar2, FacVar3, NumVar1, NumVar2, NumVar3, NumVar4) 7.4 Uma variávél contínua 7.4.1 Gráfico de pontos (scatter) plot(simData$NumVar1, type = &quot;o&quot;) ## Index plot 7.4.2 Histograma hist(simData$NumVar1) ## histogram 7.4.3 Curva da densidade de probabilidade plot(density(simData$NumVar1)) ## Kernel density plot 7.4.4 Boxplot boxplot(simData$NumVar1) ## box plot 7.5 Variável categórica (ou discreta) 7.5.1 Gráfico de barras (Total) plot(simData$FacVar3) ## bar plot 7.6 Duas Variáveis contínuas plot(simData$NumVar1, type = &quot;o&quot;, ylim = c(0, max(simData$NumVar1, simData$NumVar2))) ## index plot with one variable lines(simData$NumVar2, type = &quot;o&quot;, lty = 2, col = &quot;red&quot;) ## add another variable 7.6.1 Gráfico de densidade de probabilidade (density plots) Exemplo de https://stat.ethz.ch/pipermail/r-help/2006-August/111865.html, onde um gráfico “vazio” é produzido e depois preeenchido com linhas (função lines()). dv1 = density(simData$NumVar1) dv2 = density(simData$NumVar2) plot(range(dv1$x, dv2$x), range(dv1$y, dv2$y), type = &quot;n&quot;, xlab = &quot;NumVar1(red) and NumVar2 (blue)&quot;, ylab = &quot;Density&quot;) lines(dv1, col = &quot;red&quot;) lines(dv2, col = &quot;blue&quot;) 7.6.2 Gráfico de pontos x,y (scatterplots) plot(simData$NumVar1, simData$NumVar2) 7.7 Duas Variáves categóricas 7.7.1 Mosaico (Mosaic plot) plot(table(simData$FacVar2, simData$FacVar3)) 7.7.2 Gráfico de Barras (barplots) bartable = table(simData$FacVar2, simData$FacVar3) ## get the cross tab barplot(bartable, beside = TRUE, legend = levels(unique(simData$FacVar2))) ## plot 7.7.3 Barras Empillhadas (stacked) barplot(bartable, legend = levels(unique(simData$FacVar2))) ## stacked 7.7.4 Barras Empillhadas 100% (stacked 100%) Transformando a tabela para proporções barplot(prop.table(bartable, 2) * 100, legend = levels(unique(simData$FacVar2))) ## usando prop.table 7.8 Duas variáveis: Uma categórica e outra numérica 7.8.1 Box plots: variáveis numéricas por categoria plot(simData$FacVar1, simData$NumVar1) 7.8.2 Gráfico de densidade de probabilidade por categoria level1 = simData[simData$FacVar1 == &quot;level1&quot;, ] level2 = simData[simData$FacVar1 == &quot;level2&quot;, ] dv3 = density(level1$NumVar1) dv4 = density(level2$NumVar1) plot(range(dv3$x, dv4$x), range(dv3$y, dv4$y), type = &quot;n&quot;, xlab = &quot;NumVar1 at Level1 (red) and NumVar1 at Level2 (blue)&quot;, ylab = &quot;Density&quot;) lines(dv3, col = &quot;red&quot;) lines(dv4, col = &quot;blue&quot;) 7.8.3 Média de uma variável numérica considerando sua categoria Verifique como funciona aggregate(), e qual é o retorno de cada função usada como argumento. list(simData$FacVar3) aggregate(simData$NumVar1, list(simData$FacVar3), mean) meanagg = aggregate(simData$NumVar1, list(simData$FacVar3), mean) meanagg ## Group.1 x ## 1 levelI 998.8154 ## 2 levelII 992.0538 ## 3 levelIII 1010.3125 ## 4 levelIV 1006.7492 dotchart(meanagg$x, labels = meanagg$Group.1) ## Dot Chart Gráfico de barras usando a média barplot(meanagg$x, names.arg = meanagg$Group.1) ## Bar plot Questão: O gráfico anterior é aproproado para comparar as médias (um valor pontual)? Escolha um gráfico melhor :) 7.9 Três variáveis discretas (categorias ou fatores em R) Arrumando os gráficos matricialmente com a função par() par(mfrow = c(1, 2)) bar1table = table(level1$FacVar2, level1$FacVar3) barplot(bar1table, beside = TRUE, main = &quot;FacVar1=level1&quot;) bar2table = table(level2$FacVar2, level2$FacVar3) barplot(bar2table, beside = TRUE, main = &quot;FacVar1=level2&quot;, legend = levels(unique(level2$FacVar2))) par(mfrow = c(1,1)) #retornando ao normal 7.10 Três Variáveis: Uma númérica e duas categóricas 7.10.1 Boxplot considerando a interação entre as duas variáveis categóricas Considerando que cada variável aleatória tem 3 categorias, existem seis pares possíves, cada um podendo influenciar a variável contínua de maneira distinta. boxplot(NumVar1 ~ interaction(FacVar1, FacVar2), data = simData) 7.10.2 Média da variável numérica para cada par de interação das variáveis categóricas meanaggg = aggregate(simData$NumVar1, list(simData$FacVar1, simData$FacVar2), mean) meanaggg = meanaggg[order(meanaggg$Group.1), ] meanaggg$color[meanaggg$Group.2 == &quot;levelA&quot;] = &quot;red&quot; meanaggg$color[meanaggg$Group.2 == &quot;levelB&quot;] = &quot;blue&quot; meanaggg$color[meanaggg$Group.2 == &quot;levelC&quot;] = &quot;darkgreen&quot; meanaggg ## Group.1 Group.2 x color ## 1 level1 levelA 1004.8489 red ## 3 level1 levelB 996.3175 blue ## 5 level1 levelC 1011.7713 darkgreen ## 2 level2 levelA 1004.5125 red ## 4 level2 levelB 989.9144 blue ## 6 level2 levelC 1004.0450 darkgreen dotchart(meanaggg$x, labels = meanaggg$Group.2, groups = meanaggg$Group.1, color = meanaggg$color) ## dotchart 7.10.3 Gráfico de interação (interaction plot) Uma categoria eixo x e a outra no símbolo utilizado. interaction.plot(meanaggg$Group.2, meanaggg$Group.1, meanaggg$x, type = &quot;b&quot;, col = c(1:2), pch = c(18, 24)) ## interaction plot - line plots of means 7.10.4 Gráfico de barras Veja a dificuldade de identificar tais variações em um gráfico de barras par(mfrow = c(1, 2)) meanaggg ## Group.1 Group.2 x color ## 1 level1 levelA 1004.8489 red ## 3 level1 levelB 996.3175 blue ## 5 level1 levelC 1011.7713 darkgreen ## 2 level2 levelA 1004.5125 red ## 4 level2 levelB 989.9144 blue ## 6 level2 levelC 1004.0450 darkgreen level1 = meanaggg[meanaggg$Group.1 == &quot;level1&quot;, ] level2 = meanaggg[meanaggg$Group.1 == &quot;level2&quot;, ] barplot(level1$x, names.arg = level1$Group.2, main = &quot;FacVar1=level1&quot;) barplot(level2$x, names.arg = level2$Group.2, main = &quot;FacVar1=level2&quot;) par(mfrow = c(1, 1)) 7.11 Três variáveis: Duas numéricas e uma variável categórica 7.11.1 Gráfico de pontos usando cor Aqui a cor é utilizada para identificar o valor da variável categorica plot(simData$NumVar1, simData$NumVar2, col = simData$FacVar1) legend(&quot;topright&quot;, levels(simData$FacVar1), fill = simData$FacVar1) #Usando pontos sólidos para melhorar a visiualização plot(simData$NumVar1, simData$NumVar2, col = simData$FacVar1, pch = 19) legend(&quot;topright&quot;, levels(simData$FacVar1), fill = simData$FacVar1) 7.12 Três variáveis numéricas 7.12.1 Gráficos de Linhas Considerando que NumVar4 varia de 2001 até 2050, vamos assumir que a mesma representaria uma data aque será usada no eixo x plot(simData$NumVar4, simData$NumVar1, type = &quot;o&quot;, ylim = c(0, max(simData$NumVar1, simData$NumVar2))) ## join dots with lines lines(simData$NumVar4, simData$NumVar2, type = &quot;o&quot;, lty = 2, col = &quot;red&quot;) ## add another line Observe que lines() permite que a gráfico poderá ser montado em níveis. Essa é uma funcionalidade muito útil, mas ainda limitada no sistema de gráficos do pacote básico. Veremos mais adiante um pacote mais poderoso implementado para explorar melhor esta possibilidade. 7.12.2 Gráfico de bolhas2 Esse é um gráfico que incorpora nos pontos definidos pelas variáveis NumVar1 and NumVar2 a informação da variável NumVar3, usando seu valor para definir o tamanho do ponto a ser plotado. radius &lt;- sqrt(simData$NumVar3/pi) symbols(simData$NumVar1, simData$NumVar2, circles = radius, inches = 0.25, fg = &quot;white&quot;, bg = &quot;red&quot;, main = &quot;Tamanho dado por NumVar3&quot;) 7.12.3 Gráfico de pares Finalmente, um gráfico de pontos (Scatterplot) na forma de uma matriz simétrica que apresenta a correlação espacial entre os pares das variáveis numéricas, coloridas por uma variável discreta. pairs(simData[, 4:7], col = simData$FacVar1, pch = 19) Na verdade, a medida que vamos incrementando a apresentação de mais informações nos gráficos, os comandos passam a ganhar maior complexidade quando usamos apenas o pacote base. No próximo capítulo veremos um pacote especialmente implementado para lidar com essa problemática, facilitado em muito a criação de gráficos mais informativos. References "],
["graficos-com-o-ggplot2.html", "Unidade 8 Gráficos com o ggplot2 8.1 Introdução 8.2 Gramática dos gráficos (Wilkinson 2005) 8.3 Primeiro exemplo 8.4 Estrutura para montagem de um gráfico 8.5 Mapeamento Visual e geometrias (Aesthetic Mapping and geometrics) 8.6 Pontos (Scatterplot) 8.7 Linhas (Ex. Regressão linear) 8.8 Smoothers 8.9 Texto (Label Points) 8.10 Aesthetic Mapping VS Assignment 8.11 Exercicio I 8.12 Recursos adicionais", " Unidade 8 Gráficos com o ggplot2 8.1 Introdução O pacote ggplot2 (Wickham and Chang 2016) permite mesmo aos usuários sem muito conhecimento de R a produzirem gráficos com aparência profissional. Mais do que isso, possibilita que os analístas de dados possam explorar e comunicar melhor as evidências existentes em um conjunto de dados, tornando seu trabalho como um todo mais robusto. 8.2 Gramática dos gráficos (Wilkinson 2005) O pacote ggplot2 incorpora um conceito moderno sobre como constriur apresentações gráficas. Esse conceito está baseado na ideia de que um gráfico deve ser construído em camadas sucessivas, e tais camadas aos poucos vão dando forma a ideia a ser comunicada. As camadas de um gráfico são (termo em inglês entre parênteses): - dados (data) - mapeamento visual (aesthetic mapping) - geometria (geometric object) - transformações (statistical transformations) - escalas (scales) - sistema de coordenadas (coordinate system) - posição (position adjustments) - faces (faceting) Essa organização permite que elementos gráficos sejam combinados de maneira flexível, sejam refinados aos poucos partindo de ideias mais abstratas. Além do que a alteração de uma camada não compromete a consitências das demais. Por exemplo, mudar o símbolo ou a cor dos pontos. Existem outros pacotes gráficos em R, alguns independentes mas outros que estendem ainda mais a abrangência do pacote ggplot2, como por exemplo: - Gráficos 3-D (pacote rgl) - Plotagem de grafos (pacote *igraph*) - Gráficos interativos (pacote *ggvis*) Para essa sessão, a referência utilizada é o material do workshop “Introduction to R” realizado em Fevereiro/2017 pelo Research consulting for the Harvard community - Data Science Services - Harvard University, confeccionado principalmente por Ista Zahn. 8.3 Primeiro exemplo 8.3.1 Dados: “Housing prices” Fonte dos Dados [https://www.lincolninst.edu/subcenters/land-values/land-prices-by-state.asp] # Importe os dados (arquivo landdata-states-2016q1.xls). housing &lt;- read.csv(&quot;../Dados/ggplot2/landdata-states.csv&quot;) head(housing[1:5]) ## State region Date Home.Value Structure.Cost ## 1 AK West 2010.25 224952 160599 ## 2 AK West 2010.50 225511 160252 ## 3 AK West 2009.75 225820 163791 ## 4 AK West 2010.00 224994 161787 ## 5 AK West 2008.00 234590 155400 ## 6 AK West 2008.25 233714 157458 8.3.2 ggplot2 VS Base Comparado com o pacote base, ggplot2 : - comandos com mais texto para gráficos simples - porém mais comandos mais simples para gráficos complexos - dados sempre devem estar em um `data.frame` - usa uma sistemática diferente para adicionar os elementos gráficos Como já vimos, para montar um histograma com o pacote base: hist(housing$Home.Value) Já usando ggplot2: library(ggplot2) #não esqueça de carregar e instalar o pacote ggplot(housing, aes(x = Home.Value)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Obs: ‘+’ significa que o próximo comando será somado na definição do gráfico Base wins! 8.3.3 ggplot2 VS base agora com gráficos mais complexos: O gráfico apresenta a evolução dos preços das casas em dois estados americanos, onde os pontos de cada estado possui uma cor distinta. plot(Home.Value ~ Date, data=subset(housing, State == &quot;MA&quot;)) points(Home.Value ~ Date, col=&quot;red&quot;, data=subset(housing, State == &quot;TX&quot;)) legend(1975, 400000, c(&quot;MA&quot;, &quot;TX&quot;), title=&quot;State&quot;, col=c(&quot;black&quot;, &quot;red&quot;), pch=c(1, 1)) Já com ggplot2: ggplot(subset(housing, State %in% c(&quot;MA&quot;, &quot;TX&quot;)), aes(x=Date, y=Home.Value, color=State))+ geom_point() ggplot2 wins! 8.4 Estrutura para montagem de um gráfico ggplot(data = &lt;default data set&gt;, aes(x = &lt;default x axis variable&gt;, y = &lt;default y axis variable&gt;, ... &lt;other default aesthetic mappings&gt;), ... &lt;other plot defaults&gt;) + geom_&lt;geom type&gt;(aes(size = &lt;size variable for this geom&gt;, ... &lt;other aesthetic mappings&gt;), data = &lt;data for this point geom&gt;, stat = &lt;statistic string or function&gt;, position = &lt;position string or function&gt;, color = &lt;&quot;fixed color specification&quot;&gt;, &lt;other arguments, possibly passed to the _stat_ function) + scale_&lt;aesthetic&gt;_&lt;type&gt;(name = &lt;&quot;scale label&quot;&gt;, breaks = &lt;where to put tick marks&gt;, labels = &lt;labels for tick marks&gt;, ... &lt;other options for the scale&gt;) + theme(plot.background = element_rect(fill = &quot;gray&quot;), ... &lt;other theme elements&gt;) 8.5 Mapeamento Visual e geometrias (Aesthetic Mapping and geometrics) 8.5.1 Aesthetic Mapping Em ggplot2 aesthetic significa “algo que pode ser visto”. Exemplo: - position (i.e., eixos x e y) - color (cor externa) - fill (cor interna usada para preencher) - shape (tipo de símbolo no caso de pontos) - linetype (tipo de linha) - size (tamanho) Cada tipo de objeto geométrico geom aceita somente um subconjunto das aesthetic, que são inseridas via função aes(). 8.5.2 Objetos geométricos (geom) Os objetos geométricos são os símbolos usados em um grafo. Exemplo: - pontos (`geom_point&#39;, para scatter plots, dot plots, etc) - linhas (`geom_line&#39;, para séries temporais, linhas de tendência, etc) - boxplot (`geom_boxplot&#39;, para boxplots!) - Um gráfico deve ter pelo menos um geomm; Nào há limite - podem ser adicionados como uma camada usando o sinal de `+` Uma lista das geom_ disponíveis pode ser visualizada usando o comando help.search(&quot;geom_&quot;, package = &quot;ggplot2&quot;) ou simplesmente teclando geom_&lt;tab&gt; em uma boa IDE R (como o Rstudio) 8.6 Pontos (Scatterplot) `geom_point’ requer que pelo menos o mapeamento de x e y tenham sido feitos. Os outros são opcionais. hp2001Q1 &lt;- subset(housing, Date == 2001.25) ggplot(hp2001Q1, aes(y = Structure.Cost, x = Land.Value)) + geom_point() Usando a log() para transformar a variável no eixo x. ggplot(hp2001Q1, aes(y = Structure.Cost, x = log(Land.Value))) + geom_point() 8.7 Linhas (Ex. Regressão linear) Como já foi dito, um gráfico usando ggplot2 pode conter mais de uma geom. Nesse caso, funciona como novas camadas fossem acrescentadas ao gráfico. Nesse exemplo, vamos incorporar ao gráfico uma linha de predição baseada na regressão linear (veremos adiamte mais detalhadamente esse assunto): hp2001Q1$pred.SC &lt;- predict(lm(Structure.Cost ~ log(Land.Value), data = hp2001Q1)) p1 &lt;- ggplot(hp2001Q1, aes(x = log(Land.Value), y = Structure.Cost)) p1 + geom_point(aes(color = Home.Value)) + geom_line(aes(y = pred.SC)) Obs: No chunk anterior a variável p1 contém a primeira camada do gráfico, e vamos reutilizá-la em outros exemplos abaixo. Aqui usamos duas geom, sendo que a cor dos pontos foi associada também a uma variável do data.frame. Automaticamente uma legenda foi criada e posicionada. 8.8 Smoothers Esse geom_ inclui uma linha de predição e uma faixa de intervalo de confiança considerando os pontos informados em aes(). Desta vez vamos reaproveitar nossa variável p1. p1 + geom_point(aes(color = Home.Value)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; 8.9 Texto (Label Points) p1 + geom_text(aes(label=State), size = 3) obs: Para mais possibilidades com textos existe o pacote ggrepel (???). ## install.packages(&quot;ggrepel&quot;) library(&quot;ggrepel&quot;) p1 + geom_point() + geom_text_repel(aes(label=State), size = 3) 8.10 Aesthetic Mapping VS Assignment É importante frisar que as variáveis são mapeadas visualmente dentro da função aes(), enquanto que mapementos visual fixo (fixed aesthetics) como o tmanho de pontos deve ser realizado fora de aes(). Por exemplo: p1 + geom_point(aes(size = 2), # Errado! 2 não é uma variável color=&quot;red&quot;) # ok -- todos os pontos devem ser *red* Mais de uma variável mapeada em aes(): p1 + geom_point(aes(color=Home.Value, shape = region)) ## Warning: Removed 1 rows containing missing values (geom_point). 8.11 Exercicio I Os dados para este exercício estão em no arquivo ‘EconomistData.csv’. A fonte original dos dados é: - http://www.transparency.org/content/download/64476/1031428 - http://hdrstats.undp.org/en/indicators/display_cf_xls_indicator.cfm?indicator_id=103106&amp;lang=en Esses dados revelam o Índice de Desenvolvimento Humano(HDI) e o Índice Corrupção Perceptível(CPI) de diversos países. dat &lt;- read.csv(&quot;../Dados/ggplot2/EconomistData.csv&quot;) head(dat) Se tudo estive correto, o comando abaixo deve funcionar: 1. Crie um gráfico de pontos (scatter plot) com CPI no eixo x e HDI no eixo y. 2. Colorir os pontos em azul (blue). 3. Use a região para mapear a cor dos pontos. 4. Aumente o tamanho dos pontos (size = 2) 5. Associe o tamanho dos pontos ao HDI.Rank 8.12 Recursos adicionais ggplot2: - Mailing list: [http://groups.google.com/group/ggplot2] - Wiki: [https://github.com/hadley/ggplot2/wiki] - Website: [http://had.co.nz/ggplot2/] - StackOverflow: [http://stackoverflow.com/questions/tagged/ggplot] References "],
["references.html", "References", " References "]
]
